---
- name: Initialize secret variable
  ansible.builtin.set_fact:
    app_tokens_content: "{{ app_tokens_content | default('') }}"

- name: Initialize Spotify cache content variable
  ansible.builtin.set_fact:
    spotify_cache_content: "{{ spotify_cache_content | default('') }}"

- name: Check local tokens file presence
  ansible.builtin.stat:
    path: "{{ local_app_tokens_path }}"
  delegate_to: localhost
  become: false
  register: local_tokens_stat
  run_once: true

- name: Load local tokens fallback when available
  ansible.builtin.set_fact:
    app_tokens_content: "{{ lookup('file', local_app_tokens_path) }}"
  when:
    - not is_ci_environment
    - (app_tokens_content | length) == 0
    - local_tokens_stat.stat.exists

- name: Check local Spotify cache presence
  ansible.builtin.stat:
    path: "{{ local_spotify_cache_path }}"
  delegate_to: localhost
  become: false
  register: local_cache_stat
  run_once: true

- name: Remember Spotify cache availability
  ansible.builtin.set_fact:
    spotify_cache_available: "{{ (local_cache_stat.stat.exists | default(false)) | bool }}"

- name: Warn when Spotify cache is missing locally
  ansible.builtin.debug:
    msg: "Локальный файл Spotify cache не найден. Запуск потребует интерактивной авторизации."
  when:
    - not is_ci_environment
    - not local_cache_stat.stat.exists

- name: Validate required secrets
  ansible.builtin.assert:
    that:
      - app_tokens_content | length > 0
    fail_msg: "Переменная app_tokens_content должна быть передана (секрет с токенами)."

- name: Ensure application directory exists
  ansible.builtin.file:
    path: "{{ app_root }}"
    state: directory
    mode: '0755'

- name: Synchronize project sources to server
  ansible.posix.synchronize:
    src: "{{ repo_root }}/"
    dest: "{{ app_root }}"
    delete: true
    archive: true
    checksum: true
    recursive: true
    rsync_path: "sudo rsync"
    rsync_opts:
      - "--exclude=.git"
      - "--exclude=.github"
      - "--exclude=ansible"
      - "--exclude=.venv"
      - "--exclude=.pytest_cache"
      - "--exclude=.cache"
      - "--exclude=*.pyc"
      - "--exclude=.env"
  delegate_to: localhost
  become: false

- name: Ensure application uv install directory exists
  ansible.builtin.file:
    path: "{{ app_uv_install_dir }}"
    state: directory
    mode: "0755"

- name: Install uv CLI for application runtime if missing
  ansible.builtin.shell: |
    curl -LsSf https://astral.sh/uv/install.sh | sh
  args:
    creates: "{{ app_uv_binary }}"
  environment:
    UV_INSTALL_DIR: "{{ app_uv_install_dir }}"
    UV_INSTALL_VERSION: "{{ app_uv_version }}"
    UV_VERSION: "{{ app_uv_version }}"

- name: Check installed uv version for application runtime
  ansible.builtin.command:
    cmd: "{{ app_uv_binary }} --version"
  register: app_uv_check
  changed_when: false
  failed_when: false
  environment:
    PATH: "{{ app_uv_install_dir }}:{{ ansible_env.PATH }}"

- name: Ensure uv CLI is at required version for application runtime
  ansible.builtin.command:
    cmd: "{{ app_uv_binary }} self update {{ app_uv_version }}"
  when: (app_uv_version | length > 0) and (app_uv_check.rc != 0 or app_uv_version not in app_uv_check.stdout)
  changed_when: false
  environment:
    PATH: "{{ app_uv_install_dir }}:{{ ansible_env.PATH }}"

- name: Ensure application runtime virtualenv parent directory exists
  ansible.builtin.file:
    path: "{{ app_runtime_virtualenv_dir | dirname }}"
    state: directory
    mode: "0755"

- name: Check presence of uv lock file for application runtime
  ansible.builtin.stat:
    path: "{{ app_uv_requirements }}"
  register: app_uv_lock

- name: Ensure uv lock file is available for application runtime
  ansible.builtin.assert:
    that: app_uv_lock.stat.exists
    fail_msg: "uv.lock is missing at {{ app_uv_requirements }}; sync the repository before deploying application dependencies."

- name: Export runtime requirements with uv for application
  ansible.builtin.command:
    cmd: uv export --frozen --no-dev --output-file {{ app_runtime_requirements_file }}
    chdir: "{{ app_root }}"
  environment:
    UV_LINK_MODE: copy
    PATH: "{{ app_uv_install_dir }}:{{ ansible_env.PATH }}"
  changed_when: false

- name: Check if application runtime virtualenv exists
  ansible.builtin.stat:
    path: "{{ app_runtime_virtualenv_dir }}/bin/python"
  register: app_runtime_venv_stat

- name: Provision application runtime virtualenv via uv
  ansible.builtin.command:
    cmd: uv venv --clear --python {{ app_python_version }} {{ app_runtime_virtualenv_dir }}
    chdir: "{{ app_root }}"
  environment:
    UV_LINK_MODE: copy
    PATH: "{{ app_uv_install_dir }}:{{ ansible_env.PATH }}"
  when: not app_runtime_venv_stat.stat.exists

- name: Sync application runtime dependencies with uv
  ansible.builtin.command:
    cmd: uv pip sync --python {{ app_runtime_virtualenv_dir }}/bin/python {{ app_runtime_requirements_file }}
    chdir: "{{ app_root }}"
  environment:
    UV_LINK_MODE: copy
    PATH: "{{ app_uv_install_dir }}:{{ ansible_env.PATH }}"
  changed_when: false

- name: Remove exported application runtime requirements file
  ansible.builtin.file:
    path: "{{ app_runtime_requirements_file }}"
    state: absent
  changed_when: false

- name: Determine current git commit hash
  ansible.builtin.command:
    cmd: git rev-parse HEAD
    chdir: "{{ repo_root }}"
  delegate_to: localhost
  become: false
  register: deploy_version_commit
  changed_when: false

- name: Determine git tag for current commit
  ansible.builtin.command:
    cmd: git tag --points-at HEAD
    chdir: "{{ repo_root }}"
  delegate_to: localhost
  become: false
  register: deploy_version_tag
  changed_when: false

- name: Determine deployment build timestamp
  ansible.builtin.command:
    cmd: date -u +%Y-%m-%dT%H:%M:%SZ
  delegate_to: localhost
  become: false
  register: deploy_version_time
  changed_when: false

- name: Prepare deployment version metadata values
  ansible.builtin.set_fact:
    spondex_commit_value: "{{ deploy_version_commit.stdout | trim }}"
    spondex_tag_value: "{{ (deploy_version_tag.stdout_lines | select('length') | list | first) | default('', true) }}"
    spondex_build_time_value: "{{ deploy_version_time.stdout | trim }}"

- name: Build deployment version metadata
  ansible.builtin.set_fact:
    spondex_version_metadata:
      commit: "{{ spondex_commit_value }}"
      commit_short: "{{ spondex_commit_value[:7] if spondex_commit_value else '' }}"
      tag: "{{ spondex_tag_value }}"
      build_time: "{{ spondex_build_time_value }}"
      source: "deploy"
      version: "{{ spondex_tag_value if spondex_tag_value else (spondex_commit_value[:7] if spondex_commit_value else '') }}"

- name: Ensure version metadata directory exists
  ansible.builtin.file:
    path: "{{ app_root }}/.venv"
    state: directory
    mode: '0755'

- name: Write deployment version metadata to server
  ansible.builtin.copy:
    content: "{{ spondex_version_metadata | to_nice_json }}\n"
    dest: "{{ app_root }}/.venv/spondex-version.json"
    mode: '0644'

- name: Render runtime environment file
  ansible.builtin.template:
    src: env.j2
    dest: "{{ app_root }}/.env"
    mode: '0600'
    force: true
  no_log: true

- name: Validate runtime environment file
  ansible.builtin.stat:
    path: "{{ app_root }}/.env"
  register: runtime_env_stat

- name: Assert runtime environment file created
  ansible.builtin.assert:
    that:
      - runtime_env_stat.stat.exists | default(false)
      - (runtime_env_stat.stat.size | default(0)) > 0
    fail_msg: "Runtime environment file was not created on the target host."

- name: Ensure Spotify cache file absent when not provided
  when:
    - (spotify_cache_available | default(false)) | bool == false
    - (spotify_cache_content | length) == 0
  ansible.builtin.file:
    path: "{{ app_root }}/.cache"
    state: absent

- name: Copy Spotify cache file from local repository
  when:
    - not is_ci_environment
    - (spotify_cache_available | default(false)) | bool
  ansible.builtin.copy:
    src: "{{ local_spotify_cache_path }}"
    dest: "{{ app_root }}/.cache"
    mode: '0600'

- name: Write Spotify cache file from provided content
  when:
    - is_ci_environment
    - (spotify_cache_content | length) > 0
  ansible.builtin.copy:
    content: "{{ spotify_cache_content }}"
    dest: "{{ app_root }}/.cache"
    mode: '0600'

- name: Check Spotify cache file on server
  ansible.builtin.stat:
    path: "{{ app_root }}/.cache"
  register: server_cache_stat
