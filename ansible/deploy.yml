---
- name: Provision and deploy Spondex
  hosts: all
  become: true
  gather_facts: false

  vars:
    app_root: "/opt/spondex"
    deploy_app_port: "{{ (app_port | default('8888')) | int }}"
    repo_root: "{{ playbook_dir | dirname }}"
    local_app_tokens_path: "{{ repo_root }}/.env"
    local_spotify_cache_path: "{{ repo_root }}/.cache"
    is_ci_environment: "{{ (lookup('env', 'CI') | default('')) | length > 0 }}"
    ghcr_owner: "{{ ghcr_image_owner | default('sergeylavrentev') }}"
    ghcr_tag: "{{ ghcr_image_tag | default('latest') }}"
    registry_image: "ghcr.io/{{ ghcr_owner }}/spondex:{{ ghcr_tag }}"
    local_image_name: "spondex-local"
    local_image_tag: "latest"
    local_image_full: "{{ local_image_name }}:{{ local_image_tag }}"
    remote_image_archive: "/tmp/spondex-image.tar"
    deploy_image: "{{ local_image_full if not is_ci_environment else registry_image }}"
    postgres_volume_name: "spondex_postgres_data"
    postgres_db_name: "{{ postgres_db | default('music_sync') }}"
    postgres_user_name: "{{ postgres_user | default('postgres') }}"
    force_recreate_db_flag: "{{ force_recreate_db | default(false) | bool }}"

  pre_tasks:
    - name: Ensure Python 3 is available
      ansible.builtin.raw: test -x /usr/bin/python3 || (apt-get update -y && apt-get install -y python3)
      changed_when: false

    - name: Gather facts
      ansible.builtin.setup:

    - name: Initialize secret variable
      ansible.builtin.set_fact:
        app_tokens_content: "{{ app_tokens_content | default('') }}"

    - name: Initialize Spotify cache content variable
      ansible.builtin.set_fact:
        spotify_cache_content: "{{ spotify_cache_content | default('') }}"

    - name: Check local tokens file presence
      ansible.builtin.stat:
        path: "{{ local_app_tokens_path }}"
      delegate_to: localhost
      become: false
      register: local_tokens_stat
      run_once: true

    - name: Load local tokens fallback when available
      ansible.builtin.set_fact:
        app_tokens_content: "{{ lookup('file', local_app_tokens_path) }}"
      when:
        - not is_ci_environment
        - (app_tokens_content | length) == 0
        - local_tokens_stat.stat.exists

    - name: Check local Spotify cache presence
      ansible.builtin.stat:
        path: "{{ local_spotify_cache_path }}"
      delegate_to: localhost
      become: false
      register: local_cache_stat
      run_once: true

    - name: Remember Spotify cache availability
      ansible.builtin.set_fact:
        spotify_cache_available: "{{ (local_cache_stat.stat.exists | default(false)) | bool }}"

    - name: Warn when Spotify cache is missing locally
      ansible.builtin.debug:
        msg: "Локальный файл Spotify cache не найден. Запуск потребует интерактивной авторизации."
      when:
        - not is_ci_environment
        - not local_cache_stat.stat.exists

    - name: Validate required secrets
      ansible.builtin.assert:
        that:
          - app_tokens_content | length > 0
        fail_msg: "Переменная app_tokens_content должна быть передана (секрет с токенами)."

  tasks:
    - name: Smoke | Display target host
      ansible.builtin.debug:
        msg: "Smoke deploy check on {{ inventory_hostname }}"
      tags: ['smoke']

    - name: Smoke | Verify privileged command execution
      ansible.builtin.command:
        cmd: whoami
      register: smoke_whoami
      changed_when: false
      tags: ['smoke']

    - name: Smoke | Assert root privileges available
      ansible.builtin.assert:
        that:
          - smoke_whoami.stdout == 'root'
        fail_msg: "Smoke test requires ability to execute commands as root."
      tags: ['smoke']

    - name: Install base packages
      ansible.builtin.apt:
        name:
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - rsync
        state: present
        update_cache: true

    - name: Ensure directory for apt keyrings exists
      ansible.builtin.file:
        path: /etc/apt/keyrings
        state: directory
        mode: '0755'

    - name: Add Docker repository key
      ansible.builtin.get_url:
        url: https://download.docker.com/linux/debian/gpg
        dest: /etc/apt/keyrings/docker.asc
        mode: '0644'

    - name: Ensure Docker apt repository is configured
      ansible.builtin.deb822_repository:
        name: docker
        types: [deb]
        uris: https://download.docker.com/linux/debian
        suites: "{{ ansible_facts['lsb']['codename'] }}"
        components: [stable]
        signed_by: /etc/apt/keyrings/docker.asc
        state: present

    - name: Install Docker engine and compose plugin
      ansible.builtin.apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-buildx-plugin
          - docker-compose-plugin
        state: present
        update_cache: true

    - name: Ensure docker service is enabled and running
      ansible.builtin.service:
        name: docker
        state: started
        enabled: true

    - name: Ensure application directory exists
      ansible.builtin.file:
        path: "{{ app_root }}"
        state: directory
        mode: '0755'

    - name: Synchronize project sources to server
      ansible.posix.synchronize:
        src: "{{ repo_root }}/"
        dest: "{{ app_root }}"
        delete: true
        archive: true
        checksum: true
        recursive: true
        rsync_path: "sudo rsync"
        rsync_opts:
          - "--exclude=.git"
          - "--exclude=.github"
          - "--exclude=ansible"
          - "--exclude=.venv"
          - "--exclude=.pytest_cache"
          - "--exclude=.cache"
          - "--exclude=*.pyc"
          - "--exclude=.env"
      delegate_to: localhost
      become: false

    - name: Render runtime environment file
      ansible.builtin.template:
        src: env.j2
        dest: "{{ app_root }}/.env"
        mode: '0600'

    - name: Ensure Spotify cache file absent when not provided
      when:
        - (spotify_cache_available | default(false)) | bool == false
        - (spotify_cache_content | length) == 0
      ansible.builtin.file:
        path: "{{ app_root }}/.cache"
        state: absent

    - name: Copy Spotify cache file from local repository
      when:
        - not is_ci_environment
        - (spotify_cache_available | default(false)) | bool
      ansible.builtin.copy:
        src: "{{ local_spotify_cache_path }}"
        dest: "{{ app_root }}/.cache"
        mode: '0600'

    - name: Write Spotify cache file from provided content
      when:
        - is_ci_environment
        - (spotify_cache_content | length) > 0
      ansible.builtin.copy:
        content: "{{ spotify_cache_content }}"
        dest: "{{ app_root }}/.cache"
        mode: '0600'

    - name: Check Spotify cache file on server
      ansible.builtin.stat:
        path: "{{ app_root }}/.cache"
      register: server_cache_stat

    - name: Check Postgres data volume presence
      ansible.builtin.command:
        cmd: docker volume inspect {{ postgres_volume_name }}
      register: postgres_volume_inspect
      failed_when: false
      changed_when: false

    - name: Remember Postgres data volume state
      ansible.builtin.set_fact:
        postgres_volume_exists: "{{ postgres_volume_inspect.rc == 0 }}"

    - name: Stop compose stack before force database recreation
      ansible.builtin.command:
        cmd: docker compose -f docker-compose.prod.yml down --remove-orphans
        chdir: "{{ app_root }}"
      when: force_recreate_db_flag | bool

    - name: Remove Postgres data volume when forcing recreation
      ansible.builtin.command:
        cmd: docker volume rm -f {{ postgres_volume_name }}
      register: postgres_volume_remove
      failed_when: false
      when: force_recreate_db_flag | bool

    - name: Reset Postgres volume state after forced removal
      ansible.builtin.set_fact:
        postgres_volume_exists: false
      when: force_recreate_db_flag | bool

    - name: Build deployment image locally when not in CI
      ansible.builtin.command:
        cmd: docker buildx build --platform linux/amd64 -t {{ deploy_image }} --load .
        chdir: "{{ repo_root }}"
      delegate_to: localhost
      become: false
      when: not is_ci_environment

    - name: Create temporary archive for deployment image
      ansible.builtin.tempfile:
        state: file
        suffix: ".tar"
      register: local_image_archive
      delegate_to: localhost
      become: false
      when: not is_ci_environment

    - name: Save deployment image to archive
      ansible.builtin.command:
        cmd: docker save -o {{ local_image_archive.path }} {{ deploy_image }}
      delegate_to: localhost
      become: false
      when: not is_ci_environment

    - name: Upload deployment image archive to target host
      ansible.builtin.copy:
        src: "{{ local_image_archive.path }}"
        dest: "{{ remote_image_archive }}"
        mode: '0600'
      when: not is_ci_environment

    - name: Load deployment image on target host
      ansible.builtin.command:
        cmd: docker load -i {{ remote_image_archive }}
      when: not is_ci_environment

    - name: Remove deployment image archive from target host
      ansible.builtin.file:
        path: "{{ remote_image_archive }}"
        state: absent
      when: not is_ci_environment

    - name: Cleanup local deployment image archive
      ansible.builtin.file:
        path: "{{ local_image_archive.path }}"
        state: absent
      delegate_to: localhost
      become: false
      when: not is_ci_environment and local_image_archive is defined

    - name: Log in to GHCR registry when credentials are available
      when:
        - is_ci_environment
        - (ghcr_username | default('')) | length > 0
        - (ghcr_pat | default('')) | length > 0
      community.docker.docker_login:
        registry_url: ghcr.io
        username: "{{ ghcr_username }}"
        password: "{{ ghcr_pat }}"

    - name: Pull latest images and build project
      ansible.builtin.command:
        cmd: docker compose -f docker-compose.prod.yml pull
        chdir: "{{ app_root }}"
      when: is_ci_environment

    - name: Apply docker compose stack
      ansible.builtin.command:
        cmd: docker compose -f docker-compose.prod.yml up -d --remove-orphans
        chdir: "{{ app_root }}"

    - name: Wait for Postgres container to become ready
      ansible.builtin.command:
        cmd: docker compose -f docker-compose.prod.yml exec -T postgres pg_isready -U {{ postgres_user_name }} -d postgres
        chdir: "{{ app_root }}"
      register: postgres_ready_check
      retries: 12
      delay: 5
      until: postgres_ready_check.rc == 0
      changed_when: false

    - name: Inspect target database presence
      ansible.builtin.command:
        cmd: docker compose -f docker-compose.prod.yml exec -T postgres psql -U {{ postgres_user_name }} -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname='{{ postgres_db_name }}';"
        chdir: "{{ app_root }}"
      register: postgres_db_check
      changed_when: false

    - name: Remember target database state
      ansible.builtin.set_fact:
        postgres_db_exists: "{{ (postgres_db_check.stdout | default('') | trim) == '1' }}"
        postgres_apply_schema: "{{ (not (postgres_volume_exists | default(false) | bool)) or (not ((postgres_db_check.stdout | default('') | trim) == '1')) or (force_recreate_db_flag | bool) }}"

    - name: Create target database when missing
      ansible.builtin.shell: >-
        docker compose -f docker-compose.prod.yml exec -T postgres
        psql -U {{ postgres_user_name }} -d postgres
        -c "CREATE DATABASE \"{{ postgres_db_name }}\";"
      args:
        chdir: "{{ app_root }}"
      when: not (postgres_db_exists | bool)

    - name: Mark database as created
      ansible.builtin.set_fact:
        postgres_db_exists: true
      when: not (postgres_db_exists | bool)

    - name: Apply database schema when required
      ansible.builtin.shell: >-
        docker compose -f docker-compose.prod.yml exec -T postgres
        psql -U {{ postgres_user_name }} -d {{ postgres_db_name }}
        -f /docker-entrypoint-initdb.d/create_tables.sql
      args:
        chdir: "{{ app_root }}"
      when: postgres_apply_schema | bool

    - name: Copy Spotify cache into application container
      when:
        - (server_cache_stat.stat.exists | default(false)) | bool
      ansible.builtin.command:
        cmd: docker compose -f docker-compose.prod.yml cp ./.cache app:/app/.cache
        chdir: "{{ app_root }}"

    - name: Restart application container to apply Spotify cache
      when:
        - (server_cache_stat.stat.exists | default(false)) | bool
      ansible.builtin.command:
        cmd: docker compose -f docker-compose.prod.yml restart app
        chdir: "{{ app_root }}"

    - name: Show running containers
      ansible.builtin.command:
        cmd: docker compose -f docker-compose.prod.yml ps
        chdir: "{{ app_root }}"
      register: compose_ps
      changed_when: false

    - name: Display running containers
      ansible.builtin.debug:
        var: compose_ps.stdout_lines

    - name: Configure monitoring stack
      ansible.builtin.import_role:
        name: monitoring
